package engine

import (
	"testing"
	"time"

	"github.com/google/uuid"
	genapi "github.com/iworkflowio/async-output-service/genapi/go"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestInMemoryStreamImpl_CircularBufferMode(t *testing.T) {
	// Test circular buffer mode (default behavior when blockingWriteTimeoutSeconds <= 0)
	stream := NewInMemoryStreamImpl(3) // Buffer size 3
	defer stream.Stop()

	// Test basic send and receive
	t.Run("BasicSendReceive", func(t *testing.T) {
		output1 := OutputType{"message": "test1", "step": 1}
		uuid1 := uuid.New()
		timestamp1 := time.Now()

		// Send should succeed
		isTimeout, isTimeout, err := stream.Send(output1, uuid1, timestamp1, 0) // 0 = circular buffer mode
		require.NoError(t, err)
		assert.False(t, isTimeout)

		// Receive should get the output
		resp, isTimeout, err := stream.Receive(1)
		require.NoError(t, err)
		assert.False(t, isTimeout)
		assert.Equal(t, uuid1.String(), resp.OutputUuid)
		assert.Equal(t, output1, resp.Output)
		assert.Equal(t, timestamp1, resp.Timestamp)
	})

	t.Run("CircularBufferOverwrite", func(t *testing.T) {
		// Fill the buffer to capacity (3)
		outputs := []OutputType{
			{"message": "msg1", "step": 1},
			{"message": "msg2", "step": 2},
			{"message": "msg3", "step": 3},
		}
		uuids := []uuid.UUID{uuid.New(), uuid.New(), uuid.New()}

		// Send 3 messages to fill buffer
		for i := 0; i < 3; i++ {
			isTimeout, err := stream.Send(outputs[i], uuids[i], time.Now(), 0)
			require.NoError(t, err)
			assert.False(t, isTimeout)
		}

		// Send 4th message, should overwrite the first one
		output4 := OutputType{"message": "msg4", "step": 4}
		uuid4 := uuid.New()
		isTimeout, err := stream.Send(output4, uuid4, time.Now(), 0)
		require.NoError(t, err)

		// First receive should get msg2 (msg1 was overwritten)
		resp, isTimeout, err := stream.Receive(1)
		require.NoError(t, err)
		assert.False(t, isTimeout)
		assert.Equal(t, outputs[1], resp.Output) // Should be msg2

		// Second receive should get msg3
		resp, isTimeout, err = stream.Receive(1)
		require.NoError(t, err)
		assert.False(t, isTimeout)
		assert.Equal(t, outputs[2], resp.Output) // Should be msg3

		// Third receive should get msg4
		resp, isTimeout, err = stream.Receive(1)
		require.NoError(t, err)
		assert.False(t, isTimeout)
		assert.Equal(t, output4, resp.Output) // Should be msg4

		// Fourth receive should timeout (buffer empty)
		resp, isTimeout, err = stream.Receive(1)
		require.NoError(t, err)
		assert.True(t, isTimeout)
		assert.Nil(t, resp)
	})

	t.Run("ReceiveTimeout", func(t *testing.T) {
		// Create a new empty stream
		emptyStream := NewInMemoryStreamImpl(5)
		defer emptyStream.Stop()

		start := time.Now()
		resp, isTimeout, err := emptyStream.Receive(2) // 2 second timeout
		duration := time.Since(start)

		require.NoError(t, err)
		assert.True(t, isTimeout)
		assert.Nil(t, resp)
		assert.GreaterOrEqual(t, duration, 1900*time.Millisecond) // Allow some tolerance
		assert.LessOrEqual(t, duration, 2100*time.Millisecond)
	})
}

func TestInMemoryStreamImpl_BlockingQueueMode(t *testing.T) {
	// Test blocking queue mode (when blockingWriteTimeoutSeconds > 0)
	stream := NewInMemoryStreamImpl(2) // Buffer size 2
	defer stream.Stop()

	t.Run("BlockingQueueBasicOperation", func(t *testing.T) {
		output1 := OutputType{"message": "test1"}
		uuid1 := uuid.New()
		timestamp1 := time.Now()

		// Send should succeed
		isTimeout, err := stream.Send(output1, uuid1, timestamp1, 5) // 5 second timeout
		require.NoError(t, err)

		// Receive should get the output
		resp, isTimeout, err := stream.Receive(1)
		require.NoError(t, err)
		assert.False(t, isTimeout)
		assert.Equal(t, uuid1.String(), resp.OutputUuid)
		assert.Equal(t, output1, resp.Output)
	})

	t.Run("BlockingQueueTimeout", func(t *testing.T) {
		// Fill the buffer to capacity (2)
		for i := 0; i < 2; i++ {
			output := OutputType{"message": "fill", "index": i}
			isTimeout, err := stream.Send(output, uuid.New(), time.Now(), 5)
			require.NoError(t, err)
		}

		// Try to send another message with short timeout
		output3 := OutputType{"message": "should timeout"}
		start := time.Now()
		isTimeout, err := stream.Send(output3, uuid.New(), time.Now(), 1) // 1 second timeout
		duration := time.Since(start)

		require.Error(t, err)
		assert.Contains(t, err.Error(), "timeout waiting for stream space")
		assert.GreaterOrEqual(t, duration, 900*time.Millisecond) // Allow some tolerance
		assert.LessOrEqual(t, duration, 1100*time.Millisecond)
	})

	t.Run("BlockingQueueUnblocksWhenSpaceAvailable", func(t *testing.T) {
		// Create fresh stream for this test
		testStream := NewInMemoryStreamImpl(1) // Buffer size 1
		defer testStream.Stop()

		// Fill the buffer
		isTimeout, err := testStream.Send(OutputType{"message": "initial"}, uuid.New(), time.Now(), 5)
		require.NoError(t, err)

		// Start a goroutine to send with blocking
		sendComplete := make(chan error, 1)
		go func() {
			output := OutputType{"message": "delayed"}
			isTimeout, err := testStream.Send(output, uuid.New(), time.Now(), 5) // 5 second timeout
			sendComplete <- err
		}()

		// Wait a bit to ensure the send is blocking
		time.Sleep(100 * time.Millisecond)

		// Receive to make space
		_, _, err = testStream.Receive(1)
		require.NoError(t, err)

		// The blocking send should now complete
		select {
		case err := <-sendComplete:
			require.NoError(t, err)
		case <-time.After(2 * time.Second):
			t.Fatal("Send should have unblocked after receive")
		}
	})
}

func TestInMemoryStreamImpl_SyncMatchQueueMode(t *testing.T) {
	// Test sync match queue mode (inMemoryStreamSize = 0 + blockingWriteTimeoutSeconds)
	stream := NewInMemoryStreamImpl(0) // Zero capacity
	defer stream.Stop()

	t.Run("SyncMatchRequiresImmediateConsumer", func(t *testing.T) {
		// Try to send without consumer - should timeout
		output := OutputType{"message": "sync test"}
		isTimeout, err := stream.Send(output, uuid.New(), time.Now(), 1) // 1 second timeout
		require.Error(t, err)
		assert.Contains(t, err.Error(), "timeout waiting for stream space")
	})

	t.Run("SyncMatchWithActiveConsumer", func(t *testing.T) {
		// Start a consumer in a goroutine
		receiveResult := make(chan struct {
			resp      interface{}
			isTimeout bool
			err       error
		}, 1)

		go func() {
			resp, isTimeout, err := stream.Receive(5) // 5 second timeout
			receiveResult <- struct {
				resp      interface{}
				isTimeout bool
				err       error
			}{resp, isTimeout, err}
		}()

		// Wait a bit to ensure consumer is waiting
		time.Sleep(100 * time.Millisecond)

		// Now send should succeed immediately
		output := OutputType{"message": "sync success"}
		uuid1 := uuid.New()
		isTimeout, err := stream.Send(output, uuid1, time.Now(), 2)
		require.NoError(t, err)

		// Consumer should receive the message
		select {
		case result := <-receiveResult:
			require.NoError(t, result.err)
			assert.False(t, result.isTimeout)

			resp := result.resp.(*genapi.ReceiveResponse)
			assert.Equal(t, uuid1.String(), resp.OutputUuid)
			assert.Equal(t, output, resp.Output)
		case <-time.After(3 * time.Second):
			t.Fatal("Consumer should have received the message")
		}
	})
}

func TestInMemoryStreamImpl_ConcurrentAccess(t *testing.T) {
	// Use a larger buffer to avoid overwriting in circular buffer mode
	stream := NewInMemoryStreamImpl(100)
	defer stream.Stop()

	t.Run("ConcurrentSendReceive", func(t *testing.T) {
		numSenders := 5
		numMessages := 10

		// Start multiple senders
		sendersComplete := make(chan bool, numSenders)
		for i := 0; i < numSenders; i++ {
			go func(senderID int) {
				defer func() { sendersComplete <- true }()
				for j := 0; j < numMessages; j++ {
					output := OutputType{"sender": senderID, "message": j}
					isTimeout, err := stream.Send(output, uuid.New(), time.Now(), 0)
					assert.NoError(t, err)
				}
			}(i)
		}

		// Wait for all senders to complete
		for i := 0; i < numSenders; i++ {
			<-sendersComplete
		}

		// Receive all messages
		receivedCount := 0
		for receivedCount < numSenders*numMessages {
			_, isTimeout, err := stream.Receive(1)
			if err != nil {
				assert.NoError(t, err)
				break
			}
			if isTimeout {
				break
			}
			receivedCount++
		}

		assert.Equal(t, numSenders*numMessages, receivedCount)
	})
}

func TestInMemoryStreamImpl_Stop(t *testing.T) {
	stream := NewInMemoryStreamImpl(5)

	t.Run("StopPreventsNewOperations", func(t *testing.T) {
		// Normal operation should work
		isTimeout, err := stream.Send(OutputType{"message": "before stop"}, uuid.New(), time.Now(), 0)
		require.NoError(t, err)

		// Stop the stream
		err = stream.Stop()
		require.NoError(t, err)

		// Operations after stop should fail
		err = stream.Send(OutputType{"message": "after stop"}, uuid.New(), time.Now(), 0)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "stream is stopped")

		_, _, err = stream.Receive(1)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "stream is stopped")
	})

	t.Run("StopIsIdempotent", func(t *testing.T) {
		// Multiple stops should not cause issues
		err := stream.Stop()
		assert.NoError(t, err)

		err = stream.Stop()
		assert.NoError(t, err)
	})

	t.Run("ConcurrentStopAndSend", func(t *testing.T) {
		// Test that Stop() can be called safely while Send operations are happening
		testStream := NewInMemoryStreamImpl(1)
		
		numGoroutines := 10
		results := make(chan error, numGoroutines)
		
		// Start multiple goroutines trying to send with blocking timeout
		for i := 0; i < numGoroutines; i++ {
			go func(id int) {
				isTimeout, err := testStream.Send(
					OutputType{"message": "concurrent", "id": id}, 
					uuid.New(), 
					time.Now(), 
					1, // 1 second timeout - will block on full buffer
				)
				results <- err
			}(i)
		}
		
		// Let some sends start and likely block
		time.Sleep(50 * time.Millisecond)
		
		// Stop the stream
		err := testStream.Stop()
		require.NoError(t, err)
		
		// Collect all results - some may have completed, others may have failed
		successCount := 0
		errorCount := 0
		for i := 0; i < numGoroutines; i++ {
			err := <-results
			if err != nil {
				// Error could be either "stream is stopped" or "timeout waiting for stream space"
				assert.True(t, 
					err.Error() == "stream is stopped" || 
					err.Error() == "timeout waiting for stream space (424)")
				errorCount++
			} else {
				successCount++
			}
		}
		
		// Verify no panics occurred and operations completed
		assert.Equal(t, numGoroutines, successCount+errorCount)
	})

	t.Run("ConcurrentStopAndReceive", func(t *testing.T) {
		// Test that Stop() can be called safely while Receive operations are happening
		testStream := NewInMemoryStreamImpl(1)
		
		numGoroutines := 5
		results := make(chan struct {
			resp      *genapi.ReceiveResponse
			isTimeout bool
			err       error
		}, numGoroutines)
		
		// Start multiple goroutines trying to receive
		for i := 0; i < numGoroutines; i++ {
			go func() {
				resp, isTimeout, err := testStream.Receive(2) // 2 second timeout
				results <- struct {
					resp      *genapi.ReceiveResponse
					isTimeout bool
					err       error
				}{resp, isTimeout, err}
			}()
		}
		
		// Let some receives start
		time.Sleep(50 * time.Millisecond)
		
		// Stop the stream
		err := testStream.Stop()
		require.NoError(t, err)
		
		// Collect all results
		errorCount := 0
		timeoutCount := 0
		for i := 0; i < numGoroutines; i++ {
			result := <-results
			if result.err != nil {
				assert.Contains(t, result.err.Error(), "stream is stopped")
				errorCount++
			} else if result.isTimeout {
				timeoutCount++
			}
		}
		
		// Verify no panics occurred and operations completed
		assert.Equal(t, numGoroutines, errorCount+timeoutCount)
	})
}

func TestInMemoryStreamImpl_EdgeCases(t *testing.T) {
		t.Run("ZeroCapacityCircularBuffer", func(t *testing.T) {
		stream := NewInMemoryStreamImpl(0)
		defer stream.Stop()

		// In circular buffer mode (blockingWriteTimeoutSeconds = 0), 
		// zero capacity should still work but immediately "overwrite" (data is lost)
		isTimeout, err := stream.Send(OutputType{"message": "test"}, uuid.New(), time.Now(), 0)
		assert.NoError(t, err) // Should succeed but data is lost

		// Receive should timeout since message was immediately lost
		_, isTimeout, err := stream.Receive(1)
		assert.NoError(t, err)
		assert.True(t, isTimeout)
	})

	t.Run("NegativeBlockingTimeout", func(t *testing.T) {
		stream := NewInMemoryStreamImpl(1)
		defer stream.Stop()

		// Negative timeout should use circular buffer mode
		isTimeout, err := stream.Send(OutputType{"message": "test"}, uuid.New(), time.Now(), -1)
		assert.NoError(t, err)
	})
}
